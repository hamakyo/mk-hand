<!DOCTYPE html>
<html lang="ja">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cybernetic Hand AR Interface v2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
      @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

      body {
        background-color: #000;
        color: #00ffcc;
        font-family: 'Share Tech Mono', monospace;
        overflow: hidden;
        margin: 0;
        padding: 0;
      }

      #canvas-container {
        position: relative;
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #000;
      }

      canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      video {
        display: none;
      }

      .hud-overlay {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 20;
        pointer-events: none;
        text-shadow: 0 0 2px #000, 0 0 5px #000;
      }

      .hud-box {
        border: 1px solid #00ffcc;
        padding: 10px;
        background: rgba(0, 20, 20, 0.4);
        box-shadow: 0 0 10px #00ffcc;
        margin-bottom: 10px;
        backdrop-filter: blur(2px);
      }

      .controls {
        position: absolute;
        bottom: 20px;
        right: 20px;
        z-index: 30;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid #00ffcc;
        padding: 15px;
        border-radius: 5px;
        backdrop-filter: blur(4px);
        display: flex;
        flex-direction: column;
        gap: 15px;
        /* Gapを少し広げました */
        width: 200px;
        /* 幅を指定してスライダーを見やすく */
      }

      button {
        background: rgba(0, 0, 0, 0.5);
        color: #00ffcc;
        border: 1px solid #00ffcc;
        padding: 5px 10px;
        cursor: pointer;
        font-family: 'Share Tech Mono', monospace;
        text-transform: uppercase;
        transition: all 0.3s;
        font-size: 11px;
        flex: 1;
      }

      button:hover {
        background: #00ffcc;
        color: #000;
        box-shadow: 0 0 15px #00ffcc;
      }

      button.active {
        background: #00ffcc;
        color: #000;
        box-shadow: 0 0 10px #00ffcc;
      }

      /* Range Slider Styling */
      input[type=range] {
        -webkit-appearance: none;
        width: 100%;
        background: transparent;
      }

      input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 16px;
        width: 16px;
        border-radius: 50%;
        background: #00ffcc;
        cursor: pointer;
        margin-top: -6px;
        box-shadow: 0 0 10px #00ffcc;
      }

      input[type=range]::-webkit-slider-runnable-track {
        width: 100%;
        height: 4px;
        cursor: pointer;
        background: rgba(0, 255, 204, 0.3);
        border-radius: 2px;
        border: 1px solid #00ffcc;
      }

      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 24px;
        color: #00ffcc;
        text-align: center;
        z-index: 50;
        animation: blink 1s infinite;
        text-shadow: 0 0 10px #000;
      }

      .error-message {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(50, 0, 0, 0.9);
        border: 2px solid #ff0055;
        padding: 20px;
        color: #ff0055;
        text-align: center;
        z-index: 100;
        max-width: 80%;
      }

      @keyframes blink {
        0% {
          opacity: 0.3;
        }

        50% {
          opacity: 1;
        }

        100% {
          opacity: 0.3;
        }
      }

      .system-status {
        color: #ff0055;
      }

      .orange-text {
        color: #ffaa00;
      }

      .blue-text {
        color: #0088ff;
      }

      .green-text {
        color: #00ff88;
      }
    </style>
  </head>

  <body>

    <div id="loading" class="loading">
      <div>INITIALIZING NEURAL LINK...</div>
      <div style="font-size: 14px; margin-top: 10px;">[Please Allow Camera Access]</div>
    </div>

    <div id="error-display" class="error-message">
      <h2 class="text-xl font-bold mb-2">CRITICAL ERROR</h2>
      <p id="error-text" class="mb-4 text-sm">Camera unavailable.</p>
      <button onclick="location.reload()">REBOOT SYSTEM</button>
    </div>

    <div id="canvas-container">
      <video id="input_video" playsinline></video>
      <canvas id="output_canvas"></canvas>
    </div>

    <div class="hud-overlay">
      <div class="hud-box">
        <h1 class="text-2xl font-bold mb-1">PROJECT: MK-HAND</h1>
        <div class="text-xs">SYS.VER: 9.1.0 // PARAMETER OVERRIDE</div>
        <div class="text-xs mt-1">FPS: <span id="fps-counter">00</span></div>
      </div>
      <div class="hud-box" style="width: 220px;">
        <div class="text-sm border-b border-[#00ffcc] mb-2">BIO-METRICS</div>
        <div class="flex justify-between text-xs">
          <span>L-HAND:</span> <span id="l-hand-status" class="system-status">OFFLINE</span>
        </div>
        <div class="flex justify-between text-xs">
          <span>R-HAND:</span> <span id="r-hand-status" class="system-status">OFFLINE</span>
        </div>
        <div class="flex justify-between text-xs mt-2">
          <span>GESTURE:</span> <span id="gesture-display">NONE</span>
        </div>
      </div>
    </div>

    <div class="controls">
      <div>
        <div class="text-xs mb-1 text-center">RENDER MODE</div>
        <div class="flex gap-2 justify-center">
          <button id="btn-tech" onclick="setMode('tech')" class="active">MECH</button>
          <button id="btn-skeleton" onclick="setMode('skeleton')">X-RAY</button>
          <button id="btn-particles" onclick="setMode('particles')">NEON</button>
        </div>
      </div>

      <div>
        <div class="text-xs mb-1 text-center">ANALYSIS TOOLS</div>
        <div class="flex gap-2 justify-center">
          <button id="btn-angle" onclick="toggleAngle()" class="active">ANGLE: ON</button>
        </div>
      </div>

      <div>
        <div class="text-xs mb-1 text-center flex justify-between">
          <span>HOLO SIZE</span>
          <span id="scale-val-display" style="color:#fff;">1.20</span>
        </div>
        <input type="range" id="holo-scale-slider" min="0.5" max="3.0" step="0.1" value="1.2">
      </div>
    </div>

    <script>
      const videoElement = document.getElementById('input_video');
      const canvasElement = document.getElementById('output_canvas');
      const canvasCtx = canvasElement.getContext('2d');
      const loadingScreen = document.getElementById('loading');
      const errorDisplay = document.getElementById('error-display');
      const errorText = document.getElementById('error-text');
      const fpsCounter = document.getElementById('fps-counter');
      const gestureDisplay = document.getElementById('gesture-display');

      let currentMode = 'tech';
      let showAngleAnalysis = true;

      // --- スライダー用変数 ---
      let holoScaleMultiplier = 1.2; // デフォルト値
      const scaleSlider = document.getElementById('holo-scale-slider');
      const scaleDisplay = document.getElementById('scale-val-display');

      // スライダー操作イベント
      scaleSlider.addEventListener('input', (e) => {
        holoScaleMultiplier = parseFloat(e.target.value);
        scaleDisplay.innerText = holoScaleMultiplier.toFixed(2);
      });
      // ---------------------

      let lastTime = 0;
      let frameCount = 0;
      let fpsTimer = 0;

      // Particle System
      const particles = [];
      const MAX_PARTICLES = 200;

      // Hologram Animation States
      let holoStates = {
        left: { type: 'none', active: false, scale: 0, alpha: 0, rotationSpeed: 0 },
        right: { type: 'none', active: false, scale: 0, alpha: 0, rotationSpeed: 0 }
      };

      const C_CYAN = '#00ffcc';
      const C_RED = '#ff0055';
      const C_BLUE = '#0088ff';
      const C_WHITE = '#ffffff';
      const C_ORANGE = '#ffaa00';
      const C_PURPLE = '#aa00ff';
      const C_GREEN = '#00ff88';

      function setMode(mode) {
        currentMode = mode;
        document.getElementById('btn-tech').className = mode === 'tech' ? 'active' : '';
        document.getElementById('btn-skeleton').className = mode === 'skeleton' ? 'active' : '';
        document.getElementById('btn-particles').className = mode === 'particles' ? 'active' : '';
      }

      function toggleAngle() {
        showAngleAnalysis = !showAngleAnalysis;
        const btn = document.getElementById('btn-angle');
        if (showAngleAnalysis) {
          btn.innerText = "ANGLE: ON";
          btn.className = "active";
        } else {
          btn.innerText = "ANGLE: OFF";
          btn.className = "";
        }
      }

      function showError(message) {
        loadingScreen.style.display = 'none';
        errorDisplay.style.display = 'block';
        errorText.innerText = message;
      }

      const dist = (a, b) => Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));

      function isHandOpen(landmarks) {
        const wrist = landmarks[0];
        const tips = [4, 8, 12, 16, 20];
        const pips = [2, 6, 10, 14, 18];
        let openFingers = 0;
        for (let i = 0; i < 5; i++) {
          if (dist(landmarks[tips[i]], wrist) > dist(landmarks[pips[i]], wrist)) openFingers++;
        }
        return openFingers >= 4;
      }

      function isPeaceSign(landmarks) {
        const wrist = landmarks[0];
        const indexExt = dist(landmarks[8], wrist) > dist(landmarks[6], wrist);
        const middleExt = dist(landmarks[12], wrist) > dist(landmarks[10], wrist);
        const ringCurled = dist(landmarks[16], wrist) < dist(landmarks[14], wrist);
        const pinkyCurled = dist(landmarks[20], wrist) < dist(landmarks[18], wrist);
        return indexExt && middleExt && ringCurled && pinkyCurled;
      }

      // --- Particle System ---
      class Particle {
        constructor(x, y, color) {
          this.x = x;
          this.y = y;
          this.color = color;
          this.angle = Math.random() * Math.PI * 2;
          this.speed = Math.random() * 4 + 1;
          this.size = Math.random() * 2 + 1;
          this.life = 1.0;
          this.decay = Math.random() * 0.03 + 0.01;
        }
        update() {
          this.x += Math.cos(this.angle) * this.speed;
          this.y += Math.sin(this.angle) * this.speed;
          this.life -= this.decay;
          this.size *= 0.96;
        }
        draw(ctx) {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = this.color.replace('ALPHA', this.life);
          ctx.fill();
        }
      }

      function emitParticles(x, y, colorType = 'cyan') {
        if (particles.length < MAX_PARTICLES) {
          let color1, color2;
          if (colorType === 'cyan') {
            color1 = `rgba(0, 255, 255, ALPHA)`;
            color2 = `rgba(100, 200, 255, ALPHA)`;
          } else if (colorType === 'green') {
            color1 = `rgba(0, 255, 136, ALPHA)`;
            color2 = `rgba(200, 255, 200, ALPHA)`;
          } else if (colorType === 'neutral') {
            color1 = `rgba(100, 255, 255, ALPHA)`;
            color2 = `rgba(50, 100, 100, ALPHA)`;
          }
          for (let i = 0; i < 5; i++) {
            particles.push(new Particle(x, y, i % 2 === 0 ? color1 : color2));
          }
        }
      }

      function updateParticles(ctx) {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.update();
          if (p.life <= 0) {
            particles.splice(i, 1);
          } else {
            p.draw(ctx);
          }
        }
      }

      function onResults(results) {
        if (loadingScreen.style.display !== 'none') loadingScreen.style.display = 'none';

        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.globalAlpha = 1.0;
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        updateHUD(results);
        updateParticles(canvasCtx);

        let foundLeft = false;
        let foundRight = false;
        let currentGestureText = "NONE";
        let currentGestureClass = "";
        let currentGestureColor = C_CYAN;

        if (results.multiHandLandmarks) {
          for (const [index, landmarks] of results.multiHandLandmarks.entries()) {
            const label = results.multiHandedness[index].label;
            const isLeft = label === 'Left';
            if (isLeft) foundLeft = true; else foundRight = true;

            if (currentMode === 'tech') drawMechanicalHand(landmarks);
            else if (currentMode === 'skeleton') drawXRayHand(landmarks);
            else if (currentMode === 'particles') drawNeonHand(landmarks);

            if (showAngleAnalysis) drawThumbIndexAngle(landmarks);

            // Gesture Detection
            const isPeace = isPeaceSign(landmarks);
            const isOpen = isHandOpen(landmarks);
            const animState = isLeft ? holoStates.left : holoStates.right;

            // Determine target state (Priority: Peace > Open)
            let targetType = 'none';
            if (isPeace) targetType = 'peace';
            else if (isOpen) targetType = 'ring';

            const palmX = (landmarks[0].x + landmarks[9].x) / 2 * canvasElement.width;
            const palmY = (landmarks[0].y + landmarks[9].y) / 2 * canvasElement.height;

            if (targetType !== 'none') {
              if (animState.type !== targetType) {
                animState.type = targetType;
                animState.scale = 0.5;
              }
              animState.active = true;
              animState.scale = Math.min(animState.scale + 0.1, 1.0);
              animState.alpha = Math.min(animState.alpha + 0.05, 1.0);
              animState.rotationSpeed = Math.min(animState.rotationSpeed + 0.01, 1.5);

              if (targetType === 'peace') {
                currentGestureText = "PEACE PROTOCOL";
                currentGestureClass = "green-text";
                currentGestureColor = C_GREEN;
                emitParticles(palmX, palmY, 'green');
              } else {
                currentGestureText = "HOLO-RING ACTIVE";
                currentGestureClass = "blue-text";
                currentGestureColor = C_BLUE;
                emitParticles(palmX, palmY, 'cyan');
              }
            } else {
              animState.active = false;
              animState.scale = Math.max(animState.scale - 0.1, 0);
              animState.alpha = Math.max(animState.alpha - 0.1, 0);
              animState.rotationSpeed = Math.max(animState.rotationSpeed - 0.05, 0);
              emitParticles(palmX, palmY, 'neutral');
            }

            if (animState.alpha > 0.01) {
              if (animState.type === 'peace') {
                drawPeaceHolo(landmarks, animState.scale, animState.alpha, animState.rotationSpeed);
              } else if (animState.type === 'ring') {
                drawCyberRing(landmarks, animState.scale, animState.alpha, animState.rotationSpeed);
              }
            }
          }
        }

        if (!foundLeft && !foundRight) {
          gestureDisplay.innerText = "NONE";
          gestureDisplay.className = "";
          gestureDisplay.style.color = C_CYAN;
        } else if (currentGestureText !== "NONE") {
          gestureDisplay.innerText = currentGestureText;
          gestureDisplay.className = currentGestureClass;
          gestureDisplay.style.color = currentGestureColor;
        } else {
          gestureDisplay.innerText = "STANDBY";
          gestureDisplay.className = "";
          gestureDisplay.style.color = C_CYAN;
        }

        const now = performance.now();
        frameCount++;
        if (now - fpsTimer > 1000) {
          fpsCounter.innerText = frameCount;
          frameCount = 0;
          fpsTimer = now;
        }
        canvasCtx.restore();
      }

      function updateHUD(results) {
        const lHand = document.getElementById('l-hand-status');
        const rHand = document.getElementById('r-hand-status');
        let leftFound = false;
        let rightFound = false;
        if (results.multiHandedness) {
          for (const hand of results.multiHandedness) {
            if (hand.label === 'Left') leftFound = true;
            if (hand.label === 'Right') rightFound = true;
          }
        }
        lHand.innerText = leftFound ? "CONNECTED" : "SEARCHING...";
        lHand.className = leftFound ? "" : "system-status";
        lHand.style.color = leftFound ? C_CYAN : C_RED;
        rHand.innerText = rightFound ? "CONNECTED" : "SEARCHING...";
        rHand.className = rightFound ? "" : "system-status";
        rHand.style.color = rightFound ? C_CYAN : C_RED;
      }

      // --- PEACE HOLOGRAM ---
      function drawPeaceHolo(landmarks, scale, alpha, speedMultiplier) {
        const getCoord = (idx) => ({
          x: landmarks[idx].x * canvasElement.width,
          y: landmarks[idx].y * canvasElement.height
        });

        const wrist = getCoord(0);
        const middleMCP = getCoord(9);
        const cx = (wrist.x + middleMCP.x) / 2;
        const cy = (wrist.y + middleMCP.y) / 2;

        // 【変更点】 1.2 を holoScaleMultiplier 変数に変更
        const handSize = Math.sqrt(Math.pow(wrist.x - middleMCP.x, 2) + Math.pow(wrist.y - middleMCP.y, 2)) * holoScaleMultiplier;

        const baseRadius = handSize * scale;
        const time = (performance.now() / 1000);

        canvasCtx.save();
        canvasCtx.translate(cx, cy);

        canvasCtx.shadowBlur = 15;
        canvasCtx.shadowColor = C_GREEN;

        const rSymbol = baseRadius * 0.7;

        canvasCtx.beginPath();
        canvasCtx.arc(0, 0, rSymbol, 0, Math.PI * 2);
        canvasCtx.moveTo(0, -rSymbol);
        canvasCtx.lineTo(0, rSymbol);
        const diagAngle = Math.PI / 4;
        canvasCtx.moveTo(0, 0);
        canvasCtx.lineTo(rSymbol * Math.sin(diagAngle), rSymbol * Math.cos(diagAngle));
        canvasCtx.moveTo(0, 0);
        canvasCtx.lineTo(-rSymbol * Math.sin(diagAngle), rSymbol * Math.cos(diagAngle));

        canvasCtx.strokeStyle = `rgba(0, 255, 136, ${alpha})`;
        canvasCtx.lineWidth = 5;
        canvasCtx.lineCap = "round";
        canvasCtx.stroke();

        canvasCtx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
        canvasCtx.lineWidth = 2;
        canvasCtx.stroke();

        canvasCtx.beginPath();
        canvasCtx.rotate(time * 0.5);
        canvasCtx.arc(0, 0, baseRadius * 1.0, 0, Math.PI * 2);
        canvasCtx.strokeStyle = `rgba(0, 255, 136, ${alpha * 0.5})`;
        canvasCtx.lineWidth = 2;
        canvasCtx.setLineDash([10, 10]);
        canvasCtx.stroke();
        canvasCtx.setLineDash([]);
        canvasCtx.rotate(-time * 0.5);

        const rLaurel = baseRadius * 1.3;
        const leaves = 8;
        canvasCtx.rotate(-time * 0.3);
        for (let i = 0; i < leaves; i++) {
          const angle = i * (Math.PI * 2 / leaves);
          const x = rLaurel * Math.cos(angle);
          const y = rLaurel * Math.sin(angle);

          canvasCtx.beginPath();
          canvasCtx.moveTo(x, y);
          canvasCtx.lineTo(x * 1.1, y * 1.1);
          canvasCtx.strokeStyle = `rgba(100, 255, 180, ${alpha * 0.6})`;
          canvasCtx.lineWidth = 2;
          canvasCtx.stroke();

          canvasCtx.beginPath();
          canvasCtx.arc(x * 1.15, y * 1.15, 2, 0, Math.PI * 2);
          canvasCtx.fillStyle = C_WHITE;
          canvasCtx.fill();
        }
        canvasCtx.rotate(time * 0.3);

        if (scale > 0.8) {
          canvasCtx.font = "10px Share Tech Mono";
          canvasCtx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
          canvasCtx.fillText("PEACE", -15, -baseRadius * 1.2);
          canvasCtx.fillText("MODE", -12, baseRadius * 1.4);
        }

        canvasCtx.restore();
      }


      // --- RING HOLOGRAM ---
      function drawCyberRing(landmarks, scale, alpha, speedMultiplier) {
        const getCoord = (idx) => ({
          x: landmarks[idx].x * canvasElement.width,
          y: landmarks[idx].y * canvasElement.height
        });

        const wrist = getCoord(0);
        const middleMCP = getCoord(9);
        const cx = (wrist.x + middleMCP.x) / 2;
        const cy = (wrist.y + middleMCP.y) / 2;

        // 【変更点】 元は1.6でしたが、スライダー値に0.4を足して比率を保つように設定しました
        const handSize = Math.sqrt(Math.pow(wrist.x - middleMCP.x, 2) + Math.pow(wrist.y - middleMCP.y, 2)) * (holoScaleMultiplier + 0.4);

        const baseRadius = handSize * scale;
        const time = (performance.now() / 1000);

        canvasCtx.save();
        canvasCtx.translate(cx, cy);

        if (alpha > 0.3) {
          const tips = [4, 8, 12, 16, 20];
          canvasCtx.save();
          canvasCtx.translate(-cx, -cy);

          tips.forEach(idx => {
            const tip = getCoord(idx);
            canvasCtx.beginPath();
            canvasCtx.moveTo(cx, cy);
            const segments = 4;
            for (let i = 1; i <= segments; i++) {
              const t = i / segments;
              const nextX = cx + (tip.x - cx) * t;
              const nextY = cy + (tip.y - cy) * t;
              const jitter = (Math.random() - 0.5) * 15 * scale;
              if (i < segments) {
                canvasCtx.lineTo(nextX + jitter, nextY + jitter);
              } else {
                canvasCtx.lineTo(tip.x, tip.y);
              }
            }

            canvasCtx.strokeStyle = `rgba(0, 255, 255, ${alpha * 0.6})`;
            canvasCtx.lineWidth = 1.5;
            canvasCtx.shadowColor = C_CYAN;
            canvasCtx.shadowBlur = 5;
            canvasCtx.stroke();
            canvasCtx.shadowBlur = 0;

            canvasCtx.beginPath();
            canvasCtx.arc(tip.x, tip.y, 4, 0, Math.PI * 2);
            canvasCtx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            canvasCtx.fill();
          });
          canvasCtx.restore();
        }

        const shieldGrad = canvasCtx.createRadialGradient(0, 0, baseRadius * 0.5, 0, 0, baseRadius * 1.8);
        shieldGrad.addColorStop(0, `rgba(0, 100, 255, 0)`);
        shieldGrad.addColorStop(0.8, `rgba(0, 100, 255, 0)`);
        shieldGrad.addColorStop(1, `rgba(0, 200, 255, ${alpha * 0.1})`);
        canvasCtx.beginPath();
        canvasCtx.arc(0, 0, baseRadius * 1.8, 0, Math.PI * 2);
        canvasCtx.fillStyle = shieldGrad;
        canvasCtx.fill();

        canvasCtx.shadowBlur = 10;
        canvasCtx.shadowColor = C_BLUE;

        canvasCtx.beginPath();
        canvasCtx.rotate(-time * 2);
        const rInner = baseRadius * 0.6;
        canvasCtx.arc(0, 0, rInner, 0, Math.PI * 2);
        canvasCtx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.4})`;
        canvasCtx.lineWidth = 1;
        canvasCtx.setLineDash([5, 5, 1, 5]);
        canvasCtx.stroke();
        canvasCtx.rotate(time * 2);

        canvasCtx.setLineDash([]);
        const rMain = baseRadius * 0.9;
        const segments = 4;
        canvasCtx.rotate(time * 0.4);
        for (let i = 0; i < segments; i++) {
          const startAngle = i * (Math.PI * 2 / segments);
          const endAngle = startAngle + (Math.PI * 2 / segments) - 0.3;

          canvasCtx.beginPath();
          canvasCtx.arc(0, 0, rMain, startAngle, endAngle);
          canvasCtx.strokeStyle = `rgba(0, 160, 255, ${alpha * 0.8})`;
          canvasCtx.lineWidth = 6;
          canvasCtx.stroke();

          canvasCtx.beginPath();
          canvasCtx.arc(0, 0, rMain - 6, startAngle, endAngle);
          canvasCtx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
          canvasCtx.lineWidth = 1;
          canvasCtx.stroke();
        }
        canvasCtx.rotate(-time * 0.4);

        canvasCtx.lineWidth = 1.5;
        canvasCtx.strokeStyle = `rgba(0, 255, 200, ${alpha * 0.5})`;

        canvasCtx.beginPath();
        canvasCtx.rotate(time * 0.8);
        canvasCtx.ellipse(0, 0, baseRadius * 1.2, baseRadius * 0.4, 0, 0, Math.PI * 2);
        canvasCtx.stroke();
        canvasCtx.rotate(-time * 0.8);

        canvasCtx.beginPath();
        canvasCtx.rotate(-time * 0.6 + 1);
        canvasCtx.ellipse(0, 0, baseRadius * 1.2, baseRadius * 0.4, 0, 0, Math.PI * 2);
        canvasCtx.stroke();
        canvasCtx.rotate(time * 0.6 - 1);

        const rOuter = baseRadius * 1.6;
        canvasCtx.rotate(time * 0.2);
        if (scale > 0.8) {
          canvasCtx.font = "8px Share Tech Mono";
          canvasCtx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;
          for (let i = 0; i < 8; i++) {
            const angle = i * (Math.PI * 2 / 8);
            const rx = rOuter * Math.cos(angle);
            const ry = rOuter * Math.sin(angle);
            const byte = Math.floor(Math.random() * 255).toString(16).toUpperCase();
            canvasCtx.fillText(byte, rx, ry);
          }
        }
        canvasCtx.rotate(-time * 0.2);

        const rMarkers = baseRadius * 1.8;
        for (let i = 0; i < 4; i++) {
          const angle = i * Math.PI / 2;
          const mx = rMarkers * Math.cos(angle);
          const my = rMarkers * Math.sin(angle);

          canvasCtx.beginPath();
          canvasCtx.moveTo(mx, my);
          canvasCtx.lineTo(mx * 1.1, my * 1.1);
          canvasCtx.strokeStyle = `rgba(255, 0, 100, ${alpha})`;
          canvasCtx.lineWidth = 2;
          canvasCtx.stroke();
        }

        canvasCtx.restore();
      }

      function drawThumbIndexAngle(landmarks) {
        const getCoord = (idx) => ({
          x: landmarks[idx].x * canvasElement.width,
          y: landmarks[idx].y * canvasElement.height
        });
        const wrist = getCoord(0);
        const thumbTip = getCoord(4);
        const indexTip = getCoord(8);
        const vThumb = { x: thumbTip.x - wrist.x, y: thumbTip.y - wrist.y };
        const vIndex = { x: indexTip.x - wrist.x, y: indexTip.y - wrist.y };
        const thetaThumb = Math.atan2(vThumb.y, vThumb.x);
        const thetaIndex = Math.atan2(vIndex.y, vIndex.x);
        const dot = vThumb.x * vIndex.x + vThumb.y * vIndex.y;
        const magThumb = Math.sqrt(vThumb.x * vThumb.x + vThumb.y * vThumb.y);
        const magIndex = Math.sqrt(vIndex.x * vIndex.x + vIndex.y * vIndex.y);
        let angleDeg = Math.acos(dot / (magThumb * magIndex)) * (180 / Math.PI);
        if (isNaN(angleDeg)) angleDeg = 0;

        const radius = (magThumb + magIndex) / 2 * 0.7;
        canvasCtx.beginPath();
        canvasCtx.arc(wrist.x, wrist.y, radius, Math.min(thetaThumb, thetaIndex), Math.max(thetaThumb, thetaIndex));
        canvasCtx.strokeStyle = C_ORANGE;
        canvasCtx.lineWidth = 3;
        canvasCtx.setLineDash([5, 5]);
        canvasCtx.stroke();
        canvasCtx.setLineDash([]);

        const midTheta = (thetaThumb + thetaIndex) / 2;
        const textX = wrist.x + Math.cos(midTheta) * (radius + 20);
        const textY = wrist.y + Math.sin(midTheta) * (radius + 20);
        canvasCtx.fillStyle = C_ORANGE;
        canvasCtx.font = "bold 14px Share Tech Mono";
        canvasCtx.shadowColor = "black";
        canvasCtx.shadowBlur = 4;
        canvasCtx.fillText(angleDeg.toFixed(1) + "°", textX - 15, textY);
        canvasCtx.shadowBlur = 0;
      }

      function drawMechanicalHand(landmarks) {
        const getCoord = (idx) => ({ x: landmarks[idx].x * canvasElement.width, y: landmarks[idx].y * canvasElement.height });
        const connections = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [0, 9], [9, 10], [10, 11], [11, 12], [0, 13], [13, 14], [14, 15], [15, 16], [0, 17], [17, 18], [18, 19], [19, 20], [5, 9], [9, 13], [13, 17]];

        canvasCtx.lineCap = 'butt';
        connections.forEach(([start, end]) => {
          const s = getCoord(start);
          const e = getCoord(end);
          canvasCtx.beginPath();
          canvasCtx.moveTo(s.x, s.y);
          canvasCtx.lineTo(e.x, e.y);
          canvasCtx.strokeStyle = 'rgba(10, 20, 20, 0.9)';
          canvasCtx.lineWidth = 14;
          canvasCtx.stroke();
          canvasCtx.beginPath();
          canvasCtx.moveTo(s.x, s.y);
          canvasCtx.lineTo(e.x, e.y);
          canvasCtx.strokeStyle = 'rgba(0, 255, 204, 0.4)';
          canvasCtx.lineWidth = 16;
          canvasCtx.stroke();
          canvasCtx.beginPath();
          canvasCtx.moveTo(s.x, s.y);
          canvasCtx.lineTo(e.x, e.y);
          canvasCtx.strokeStyle = C_CYAN;
          canvasCtx.lineWidth = 2;
          canvasCtx.stroke();
        });

        for (let i = 0; i < landmarks.length; i++) {
          const p = getCoord(i);
          canvasCtx.fillStyle = '#111';
          canvasCtx.strokeStyle = C_CYAN;
          canvasCtx.lineWidth = 2;
          canvasCtx.beginPath(); canvasCtx.arc(p.x, p.y, 6, 0, 2 * Math.PI); canvasCtx.fill(); canvasCtx.stroke();
          canvasCtx.beginPath(); canvasCtx.arc(p.x, p.y, 12, 0, 2 * Math.PI); canvasCtx.strokeStyle = 'rgba(0, 255, 204, 0.5)'; canvasCtx.stroke();

          if ([4, 8, 12, 16, 20].includes(i)) {
            canvasCtx.fillStyle = C_CYAN;
            canvasCtx.font = 'bold 12px Share Tech Mono';
            canvasCtx.shadowColor = "black";
            canvasCtx.shadowBlur = 4;
            canvasCtx.fillText(`TRK:${i}`, p.x + 15, p.y);
            canvasCtx.shadowBlur = 0;
            canvasCtx.strokeStyle = C_RED;
            canvasCtx.lineWidth = 2;
            canvasCtx.beginPath(); canvasCtx.moveTo(p.x - 8, p.y); canvasCtx.lineTo(p.x + 8, p.y);
            canvasCtx.moveTo(p.x, p.y - 8); canvasCtx.lineTo(p.x, p.y + 8); canvasCtx.stroke();
          }
        }
        const wrist = getCoord(0);
        canvasCtx.fillStyle = 'rgba(0, 20, 20, 0.85)';
        canvasCtx.strokeStyle = C_CYAN;
        canvasCtx.fillRect(wrist.x - 40, wrist.y, 80, 50);
        canvasCtx.lineWidth = 2;
        canvasCtx.strokeRect(wrist.x - 40, wrist.y, 80, 50);
        canvasCtx.fillStyle = C_CYAN;
        canvasCtx.font = '10px monospace';
        for (let k = 0; k < 3; k++) {
          canvasCtx.fillText(Math.random().toString(16).substr(2, 8).toUpperCase(), wrist.x - 35, wrist.y + 15 + (k * 12));
        }
      }

      function drawXRayHand(landmarks) {
        const getCoord = (idx) => ({ x: landmarks[idx].x * canvasElement.width, y: landmarks[idx].y * canvasElement.height });
        const connections = [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [0, 9], [9, 10], [10, 11], [11, 12], [0, 13], [13, 14], [14, 15], [15, 16], [0, 17], [17, 18], [18, 19], [19, 20], [5, 9], [9, 13], [13, 17], [0, 5], [0, 17]];
        canvasCtx.shadowBlur = 10;
        canvasCtx.shadowColor = C_WHITE;
        connections.forEach(([start, end]) => {
          const s = getCoord(start);
          const e = getCoord(end);
          canvasCtx.beginPath(); canvasCtx.moveTo(s.x, s.y); canvasCtx.lineTo(e.x, e.y); canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; canvasCtx.lineWidth = 10; canvasCtx.stroke();
          canvasCtx.beginPath(); canvasCtx.moveTo(s.x, s.y); canvasCtx.lineTo(e.x, e.y); canvasCtx.strokeStyle = '#fff'; canvasCtx.lineWidth = 3; canvasCtx.stroke();
        });
        canvasCtx.shadowBlur = 0;
      }

      function drawNeonHand(landmarks) {
        const getCoord = (idx) => ({ x: landmarks[idx].x * canvasElement.width, y: landmarks[idx].y * canvasElement.height });
        const wrist = getCoord(0);
        for (let i = 1; i < landmarks.length; i++) {
          const p = getCoord(i);
          canvasCtx.beginPath();
          canvasCtx.moveTo(wrist.x, wrist.y);
          canvasCtx.lineTo(p.x, p.y);
          canvasCtx.strokeStyle = `hsla(${(frameCount * 2 + i * 10) % 360}, 100%, 50%, 0.6)`;
          canvasCtx.lineWidth = 2;
          canvasCtx.stroke();
          canvasCtx.beginPath(); canvasCtx.arc(p.x, p.y, 5, 0, 2 * Math.PI); canvasCtx.fillStyle = `hsla(${(frameCount * 5) % 360}, 100%, 80%, 1)`; canvasCtx.fill();
        }
      }

      const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
      hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
      hands.onResults(onResults);
      const camera = new Camera(videoElement, { onFrame: async () => await hands.send({ image: videoElement }), width: 1280, height: 720 });
      camera.start().catch(err => showError("CAMERA ERROR"));
    </script>
  </body>

</html>